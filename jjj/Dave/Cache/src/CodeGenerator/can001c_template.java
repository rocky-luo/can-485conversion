package CodeGenerator;

import java.util.*;
import com.ifx.davex.appjetinteract.App2JetInterface;

public class can001c_template
{
  protected static String nl;
  public static synchronized can001c_template create(String lineSeparator)
  {
    nl = lineSeparator;
    can001c_template result = new can001c_template();
    nl = null;
    return result;
  }

  public final String NL = nl == null ? (System.getProperties().getProperty("line.separator")) : nl;
  protected final String TEXT_1 = "/*CODE_BLOCK_BEGIN[CAN001.c]*/" + NL + "/*******************************************************************************" + NL + " Copyright (c) 2011, Infineon Technologies AG                                 **" + NL + " All rights reserved.                                                         **" + NL + "                                                                              **" + NL + " Redistribution and use in source and binary forms, with or without           **" + NL + " modification,are permitted provided that the following conditions are met:   **" + NL + "                                                                              **" + NL + " *Redistributions of source code must retain the above copyright notice,      **" + NL + " this list of conditions and the following disclaimer.                        **" + NL + " *Redistributions in binary form must reproduce the above copyright notice,   **" + NL + " this list of conditions and the following disclaimer in the documentation    **" + NL + " and/or other materials provided with the distribution.                       **" + NL + " *Neither the name of the copyright holders nor the names of its contributors **" + NL + " may be used to endorse or promote products derived from this software without** " + NL + " specific prior written permission.                                           **" + NL + "                                                                              **" + NL + " THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"  **" + NL + " AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **" + NL + " IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **" + NL + " ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   **" + NL + " LIABLE  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR         **" + NL + " CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **" + NL + " SUBSTITUTE GOODS OR  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS    **" + NL + " INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **" + NL + " CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)       **" + NL + " ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   **" + NL + " POSSIBILITY OF SUCH DAMAGE.                                                  **" + NL + "                                                                              **" + NL + " To improve the quality of the software, users are encouraged to share        **" + NL + " modifications, enhancements or bug fixes with Infineon Technologies AG       **" + NL + " dave@infineon.com).                                                          **" + NL + "                                                                              **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "**                                                                            **" + NL + "** PLATFORM : Infineon XMC4000 Series   \t\t\t              **" + NL + "**                                                                            **" + NL + "** COMPILER : Compiler Independent                                            **" + NL + "**                                                                            **" + NL + "** AUTHOR   : App Developer                                                   **" + NL + "**                                                                            **" + NL + "** MAY BE CHANGED BY USER [yes/no]: Yes                                       **" + NL + "**                                                                            **" + NL + "** MODIFICATION DATE : Aug 22, 2013                                           **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "/*******************************************************************************" + NL + "**                      Author(s) Identity                                    **" + NL + "********************************************************************************" + NL + "**                                                                            **" + NL + "** Initials     Name                                                          **" + NL + "** ---------------------------------------------------------------------------**" + NL + "** NPJ        App Developer                                                   **" + NL + "**                                                                            **" + NL + "*******************************************************************************/" + NL + "/*" + NL + "* Version History : " + NL + "* 12 Dec 2012\t v1.0.2\t  1. Initial revision\t\t  \t\t\t\t\t\t\t\t " + NL + "*                                                                          " + NL + "* 30 May 2013\t v1.0.4\t  1. MISRA fixes." + NL + "*                         2. Fixes concerned with the Rx pin(14.3) manual configuration issue. " + NL + "*   " + NL + "* 21 Jun 2013    v1.0.6   1. Reset of INIT & CCE bit has been removed as it shall be handled in   " + NL + "*                            MULTIPLEXER.c file of DaveSupport app." + NL + "*                         2. Removed the code concerned with PORTx_PDRx & PORTx_IOCRx register modification" + NL + "* 22 Aug 2013    v1.0.8   1. Fixes w.r.t incorrect code generation of the CAN NodeId due to multiple " + NL + "*                            reference created by the data model to a proxy register" + NL + "*/" + NL + "/**" + NL + " * @file   CAN001.c" + NL + " * " + NL + " * @App Version CAN001 <";
  protected final String TEXT_2 = ">" + NL + " *" + NL + " * @brief  CAN_Basic_CAN001 App provides non reentrant API's to configure the " + NL + " *         CAN Nodes which can be used in a non RTOS environment. It provides " + NL + " *         simple APIs to Configure CAN Nodes and to Send /Receive CAN Message " + NL + " *         objects." + NL + " *" + NL + " */" + NL + "/*******************************************************************************" + NL + " ** INCLUDE FILES                                                             **" + NL + " ******************************************************************************/" + NL + "" + NL + "/** Inclusion of header file */" + NL + "#include <DAVE3.h>" + NL;
  protected final String TEXT_3 = NL;
  protected final String TEXT_4 = "  " + NL + "/*****************************************************************************" + NL + "              DUMMY DEFINTIONS OF DEBUG LOG MACROS" + NL + "*****************************************************************************/" + NL + "/*****************************************************************************" + NL + "              DUMMY DEFINTIONS OF DEBUG LOG MACROS" + NL + "*****************************************************************************/" + NL + "/*These definitions are included here to avoid compilation errors," + NL + " since the DBG002 app is not part of the project. All the macros are defined" + NL + " as empty*/ " + NL + "#ifndef _DBG002_H_" + NL + "" + NL + "#define DBG002_RegisterCallBack(A,B,C)" + NL + "#define DBG002_I(e) " + NL + "#define DBG002_IG(e,g) " + NL + "#define DBG002_IH(e,h) " + NL + "#define DBG002_IP(e,p) " + NL + "#define DBG002_IGH(e,g,h) " + NL + "#define DBG002_IGP(e,g,p) " + NL + "#define DBG002_IHP(e,h,p) " + NL + "#define DBG002_IGHP(e,g,h,p) " + NL + "#define DBG002_N(e) " + NL + "#define DBG002_NG(e,g) " + NL + "#define DBG002_NH(e,h) " + NL + "#define DBG002_NP(e,p) " + NL + "#define DBG002_NGH(e,g,h) " + NL + "#define DBG002_NGP(e,g,p) " + NL + "#define DBG002_NHP(e,h,p) " + NL + "#define DBG002_NGHP(e,g,h,p) " + NL + "#define DBG002_ID(e) " + NL + "#define DBG002_IS(e) " + NL + "#define DBG002_ISG(e,g) " + NL + "#define DBG002_SAFETY_CRITICAL(groupid,messageid,length,value)" + NL + "#define DBG002_CRITICAL(groupid,messageid,length,value)" + NL + "#define DBG002_ERROR(groupid,messageid,length,value)" + NL + "#define DBG002_WARNING(groupid,messageid,length,value)" + NL + "#define DBG002_INFO(groupid,messageid,length,value)" + NL + "#define DBG002_TRACE(groupid,messageid,length,value)" + NL + "#define DBG002_FUNCTION_ENTRY(GID, Status) " + NL + "#define DBG002_FUNCTION_EXIT(GID, Status) " + NL + "" + NL + "#endif/* End of defintions of dummy Debug Log macros*/";
  protected final String TEXT_5 = "                  " + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Macro Definitions                             **" + NL + "*******************************************************************************/" + NL + "#define APP_GID DBG002_GID_CAN001" + NL + "" + NL + "/* message objects status mask */" + NL + "#define CAN001_CLEAR_MO_STATUS_MASK    (0x0000001BU)" + NL + "/* Node Status mask */" + NL + "#define CAN001_CLEAR_NODE_STATUS_MASK  (0x000003E0U)" + NL + "/* Macro to Enable */" + NL + "#define CAN001_LIST_BEGIN_BITMASK (0x000000FFU)" + NL + "/* Panel command for dynamic MO allocation */" + NL + "#define CAN001_PANCMD_STATIC_MO_ALLOC (0x00000002U)" + NL + "/* Panel command for MO deallocation */" + NL + "#define CAN001_PANCMD_DYN_MO_DEALLOC (0x00000004U)" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Type Definitions                              **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/*******************************************************************************" + NL + "**                 Private Function Declarations:" + NL + "*******************************************************************************/" + NL + "/**" + NL + " * @ingroup CAN001_privatefunc" + NL + " * @{" + NL + " */" + NL + " " + NL + "/**" + NL + " * @brief      Function to allocate message object from free list to node list" + NL + " *              " + NL + " * @param[in]  List Node list no" + NL + " * @param[in]  MsgObjnr Message object number to be allocated to node list" + NL + " *" + NL + " * @return     status_t " + NL + " *             MO number allocated" + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " */" + NL + "static void CAN001_lAllocateMOtoNodeList(uint8_t List,uint8_t MsgObjnr);" + NL + "" + NL + "/**" + NL + " * @brief      Function to deallocate MO from Node list to free list" + NL + " *              " + NL + " * @param[inout]  MsgObjnr Message object number to be deallocated to free list" + NL + " *" + NL + " * @return     void" + NL + " *            " + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " */" + NL + "static void CAN001_lDeallocateMsgObj(uint32_t MsgObjnr);" + NL + "" + NL + "/**" + NL + " * @brief      Function to configure message object registers" + NL + " *              " + NL + " * @param[in]  MsgObjptr Pointer to message object data structure" + NL + " * @param[in]  MsgObjnr Actual message object number" + NL + " *" + NL + " * @return     void" + NL + " *            " + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " */" + NL + "static void CAN001_lConfigMORegs" + NL + "(" + NL + "  const CAN001_MessageHandleType* MsgObjptr," + NL + "  uint8_t MsgObjnr" + NL + ");" + NL + "" + NL + "" + NL + "/**" + NL + " * @brief      Function to initialize node as per UI configuration" + NL + " *              " + NL + " * @param[in] Handle Node configuration structure" + NL + " *" + NL + " * @return     void" + NL + " *            " + NL + " * <b>Reentrant: NO </b><BR>" + NL + " * <b>Sync/Async:  Synchronous</b>" + NL + " *" + NL + " */" + NL + "static void CAN001_lNodeInit(const CAN001_HandleType* Handle);" + NL + "/**" + NL + " *@}" + NL + " */" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Constant Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Global Variable Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                      Private Constant Definitions                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "/*******************************************************************************" + NL + "**                 Function like macro definitions                            **" + NL + "*******************************************************************************/" + NL + "/*******************************************************************************" + NL + "**                      Private Function Definitions                          **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/* Function to allocate message object from free list to node list */" + NL + "static void CAN001_lAllocateMOtoNodeList(uint8_t List, uint8_t MsgObjnr)" + NL + "{" + NL + "  /* <<<DD_CAN001_nonAPI_1>>> */" + NL + "  /* Panel Command for dynamic allocation of MO to node list */" + NL + "  CAN->PANCTR = ((((uint32_t)List + 1U) << CAN_PANCTR_PANAR2_Pos)| \\" + NL + "\t\t                   ((uint32_t)MsgObjnr << CAN_PANCTR_PANAR1_Pos) | \\" + NL + "                           (CAN001_PANCMD_STATIC_MO_ALLOC));" + NL + "  /* wait until panel as done the command */" + NL + "  while ( (CAN->PANCTR & CAN_PANCTR_BUSY_Msk))" + NL + "  {}" + NL + "}" + NL + "" + NL + "" + NL + "/* Function to deallocate MO from Node list to free list */ " + NL + "static void CAN001_lDeallocateMsgObj(uint32_t MsgObjnr)" + NL + "{ " + NL + "\tuint32_t FirstMoInList0 = 0U;" + NL + "  /* <<<DD_CAN001_nonAPI_2>>> */" + NL + "  FirstMoInList0 = (CAN->LIST[0] & CAN001_LIST_BEGIN_BITMASK);" + NL + "  /* Panel Command for deallocation of MO from Node List */" + NL + "  CAN->PANCTR = ((FirstMoInList0 << CAN_PANCTR_PANAR2_Pos)| \\" + NL + "                           ((uint32_t)MsgObjnr << CAN_PANCTR_PANAR1_Pos) | \\" + NL + "                           (CAN001_PANCMD_DYN_MO_DEALLOC));" + NL + "    /* wait until panel as done the command */" + NL + "   while ( (CAN->PANCTR & CAN_PANCTR_BUSY_Msk))" + NL + "    {}" + NL + "}" + NL + "" + NL + "/* Function to configure message object registers */" + NL + "static void CAN001_lConfigMORegs(const CAN001_MessageHandleType* MsgObjptr, uint8_t MsgObjnr)" + NL + "{ " + NL + "    CAN_MO_TypeDef* CAN_MOxRegs = GET_MO_OFFSET(MsgObjnr);" + NL + "\t  uint32_t Count = 0U;" + NL + "\t  /* <<<DD_CAN001_nonAPI_3>>> */  " + NL + "    /* Disable Message object */" + NL + "    CAN_MOxRegs->MOCTR = CAN_MO_MOCTR_RESMSGVAL_Msk;   " + NL + "    if ((CAN_FrameType)MsgObjptr->IDExten == STANDARDTYPE)" + NL + "    {" + NL + "      /* Configure standard identifier and identifier mask*/" + NL + "      CAN_MOxRegs->MOAR = ((((uint32_t)2UL << CAN_MO_MOAR_PRI_Pos) & \\" + NL + "                           (uint32_t)CAN_MO_MOAR_PRI_Msk) | \\" + NL + "                           ((uint32_t)(MsgObjptr->Identifier << CAN_MO_MOAR_STDID_Pos) \\" + NL + "                           & (uint32_t)CAN_MO_MOAR_STDID_Msk));" + NL + "      if(MsgObjptr->IDEMask == 1U)" + NL + "      {" + NL + "        CAN_MOxRegs->MOAMR = ((((uint32_t)1UL << CAN_MO_MOAMR_MIDE_Pos) & \\" + NL + "        \t\t             (uint32_t)CAN_MO_MOAMR_MIDE_Msk) | \\" + NL + "                            ((uint32_t)(MsgObjptr->IDMask << CAN_MO_MOAR_STDID_Pos) \\" + NL + "                            & (uint32_t)CAN_MO_MOAR_STDID_Msk));" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        CAN_MOxRegs->MOAMR = ((((uint32_t)0UL << CAN_MO_MOAMR_MIDE_Pos) & \\" + NL + "        \t\t           (uint32_t)CAN_MO_MOAMR_MIDE_Msk) | \\" + NL + "                            ((uint32_t)CAN_MO_MOAMR_AM_Msk & (uint32_t)MsgObjptr->IDMask));" + NL + "      }                      " + NL + "    } /* if (MsgObjptr->IDExten == STANDARDTYPE) */" + NL + "    else" + NL + "    {" + NL + "        /* Configure Extended identifier and identifier mask*/" + NL + "      CAN_MOxRegs->MOAR = ((((uint32_t)2UL << CAN_MO_MOAR_PRI_Pos) & \\" + NL + "    \t\t                (uint32_t)CAN_MO_MOAR_PRI_Msk) | \\" + NL + "                           ((uint32_t)(CAN_MO_MOAR_ID_Msk & MsgObjptr->Identifier)) | \\" + NL + "                            (((uint32_t)1UL << CAN_MO_MOAR_IDE_Pos ) & \\" + NL + "                            \t\t(uint32_t)CAN_MO_MOAR_IDE_Msk));" + NL + "      CAN_MOxRegs->MOAMR = (((uint32_t)((uint32_t)MsgObjptr->IDEMask << CAN_MO_MOAMR_MIDE_Pos) & \\" + NL + "    \t\t  (uint32_t)CAN_MO_MOAMR_MIDE_Msk) | \\" + NL + "    \t\t  (uint32_t)(CAN_MO_MOAMR_AM_Msk & MsgObjptr->IDMask));" + NL + "    }" + NL + "      /* Check whether message object is transmit message object */" + NL + "      /*<<<DD_CAN001_API_3_2>>>*/" + NL + "    if (MsgObjptr->MsgObjType == TRANSMSGOBJ)" + NL + "  " + NL + "    {" + NL + "      /* Configure data length */" + NL + "      WR_REG(CAN_MOxRegs->MOFCR, (uint32_t)CAN_MO_MOFCR_DLC_Msk, \\" + NL + "                            CAN_MO_MOFCR_DLC_Pos, (uint32_t)MsgObjptr->DataLength);" + NL + "      /* Configure Data registers*/" + NL + "      for(Count = 0U; Count < MsgObjptr->DataLength; Count++) " + NL + "      {" + NL + "        if(Count < 4U)" + NL + "        {" + NL + "          WR_REG(CAN_MOxRegs->MODATAL, (uint32_t)((uint32_t)CAN_MO_MODATAL_DB0_Msk << (Count*8U)), \\" + NL + "                                        (Count*8U),(uint32_t)MsgObjptr->data[Count]);" + NL + "        }" + NL + "        else" + NL + "        {" + NL + "          WR_REG(CAN_MOxRegs->MODATAH, (uint32_t)(CAN_MO_MODATAL_DB0_Msk << ((Count-4U)*8U)), \\" + NL + "                                    ((Count-4U)*8U), (uint32_t)MsgObjptr->data[Count]);" + NL + "        } /* if(Count < 4) */" + NL + "      }  /* for(Count = 0; Count < MsgObjptr->DataLength; Count++) */" + NL + "      /* Set MO as Transmit message object and set NEWDAT bit */" + NL + "      CAN_MOxRegs->MOCTR = (CAN_MO_MOCTR_SETDIR_Msk | \\" + NL + "                                                   CAN_MO_MOCTR_SETNEWDAT_Msk);" + NL + "    }/*if (MsgType == TRANSMSGOBJ)*/" + NL + "    /*<<<DD_CAN001_API_3_3>>>*/" + NL + "    else" + NL + "    { " + NL + "      /* Set MO as Receive message object and set RXEN bit */" + NL + "      CAN_MOxRegs->MOCTR = CAN_MO_MOCTR_RESDIR_Msk;" + NL + "    } /*if(MsgType == RECMSGOBJ)*/" + NL + "    /* Reset RTSEL and Set MSGVAL ,TXEN0 and TXEN1 bits */" + NL + "  CAN_MOxRegs->MOCTR = (CAN_MO_MOCTR_SETTXEN0_Msk | \\" + NL + "                        CAN_MO_MOCTR_SETTXEN1_Msk | \\" + NL + "                        CAN_MO_MOCTR_SETRXEN_Msk | \\" + NL + "                        CAN_MO_MOCTR_SETMSGVAL_Msk );" + NL + "}" + NL + "" + NL + "/* This function will initialize node with the given handle */                 " + NL + "static void CAN001_lNodeInit(const CAN001_HandleType* Handle)" + NL + " {" + NL + "  uint32_t Count  = 0U;" + NL + "  uint8_t MsgNo;" + NL + "  CAN_MO_TypeDef* CAN_MOxRegs = CAN_MO0;" + NL + "  /* <<<DD_CAN001_nonAPI_4>>> */" + NL + "  /* Map to node register offset as per node ID */" + NL + "  CAN_NODE_TypeDef* CAN_NodexRegs = Handle->CanNodeRegs;" + NL + "  DBG002_FUNCTION_ENTRY(DBG002_GID_CAN001,CAN001_FUNCTION_ENTRY);" + NL + "  /*<<<DD_CAN001_API_1>>>*/" + NL + " " + NL + "  /* wait until panel has finished initialization */" + NL + "  while ( (CAN->PANCTR & CAN_PANCTR_BUSY_Msk))" + NL + "\t{}" + NL + "  /* set CCE and INIT bit NCR for node configuration */" + NL + "   /* Enable Alert and last error code interrupt */" + NL + "  CAN_NodexRegs->NCR |= ((uint32_t)CAN_NODE_NCR_INIT_Msk | (uint32_t)CAN_NODE_NCR_CCE_Msk);" + NL + "  /* Configure bit timing register */" + NL + "  CAN_NodexRegs->NBTR = ((uint32_t)Handle->BaudRate.DIV8 << \\" + NL + "                                          CAN_NODE_NBTR_DIV8_Pos) | \\" + NL + "                         ((uint32_t)Handle->BaudRate.TimeSEG2 << \\" + NL + "                                          CAN_NODE_NBTR_TSEG2_Pos) | \\" + NL + "                         ((uint32_t)Handle->BaudRate.TimeSEG1 << \\" + NL + "                                          CAN_NODE_NBTR_TSEG1_Pos) | \\" + NL + "                         ((uint32_t)Handle->BaudRate.SyncJumpWidth << \\" + NL + "                                            CAN_NODE_NBTR_SJW_Pos) | \\" + NL + "                         (uint32_t)Handle->BaudRate.BaudRatePresc;" + NL + "  /* Check whether loop back mode is to be enabled */" + NL + "  if ( Handle->LoopBackModeEn == CAN001_ENABLE)" + NL + "  {" + NL + "    SET_BIT(CAN_NodexRegs->NPCR, CAN_NODE_NPCR_LBM_Pos);" + NL + "  }" + NL + "  /* Allocate required number of message object to node list " + NL + "    * and configure message object */" + NL + "  for(Count = 0U; Count < Handle->NodeMONo; Count++)" + NL + "  {" + NL + "    CAN001_lAllocateMOtoNodeList(Handle->NodeID, (uint8_t)(Handle->FirstMOMapping + Count));" + NL + "    MsgNo = (uint8_t)(Handle->FirstMOMapping + Count);" + NL + "    CAN_MOxRegs = GET_MO_OFFSET(MsgNo);" + NL + "\t /* Configure MPN */" + NL + "    CAN_MOxRegs->MOIPR = (((uint32_t)Handle->NodeID << \\" + NL + "                          (CAN_MO_MOIPR_MPN_Pos + 5)) | \\" + NL + "                          (Count << CAN_MO_MOIPR_MPN_Pos));" + NL + "  }" + NL + "  DBG002_FUNCTION_EXIT(DBG002_GID_CAN001,CAN001_FUNCTION_EXIT);" + NL + "}" + NL + " " + NL + "/*******************************************************************************" + NL + "**                      Public Function Definitions                           **" + NL + "*******************************************************************************/" + NL + "" + NL + "" + NL + "/** @ingroup CAN001_publicfunc" + NL + " * @{" + NL + " */" + NL + "" + NL + "" + NL + "/* This function will initialize node with the given handle */                 " + NL + "void CAN001_Init(void)" + NL + "{" + NL + "   DBG002_FUNCTION_ENTRY(DBG002_GID_CAN001,CAN001_FUNCTION_ENTRY);" + NL + "   /* Calling CANGLOBAL App Initialization */" + NL + "   CANGLOBAL_Init();";
  protected final String TEXT_6 = NL;
  protected final String TEXT_7 = NL + "   /* Node";
  protected final String TEXT_8 = " initialization */" + NL + "   CAN001_lNodeInit(&CAN001_Handle";
  protected final String TEXT_9 = ");";
  protected final String TEXT_10 = NL + "   /* Enable Node Alert interrupt */" + NL + "   EnableNodeInterrupt(CAN001_Handle";
  protected final String TEXT_11 = ",(uint32_t)CAN_ALERT_INTERRUPT);";
  protected final String TEXT_12 = NL + "// NODE IS NOT MAPPED";
  protected final String TEXT_13 = NL + "   /* LMO";
  protected final String TEXT_14 = " Initialization */" + NL + "   (void)CAN001_ConfigMsgObj(&CAN001_Handle";
  protected final String TEXT_15 = ",&CAN001_MessageHandle";
  protected final String TEXT_16 = "_";
  protected final String TEXT_17 = ",";
  protected final String TEXT_18 = "U);";
  protected final String TEXT_19 = NL + "   /* Enable transmit interrupt */" + NL + "   EnableMOInterrupt(CAN001_Handle";
  protected final String TEXT_20 = ",(uint32_t)CAN_MO_TRANSMIT_INTERRUPT,";
  protected final String TEXT_21 = ");";
  protected final String TEXT_22 = NL + "   /* Enable receive interrupt */" + NL + "   EnableMOInterrupt(CAN001_Handle";
  protected final String TEXT_23 = ",(uint32_t)CAN_MO_RECEIVE_INTERRUPT,";
  protected final String TEXT_24 = ");";
  protected final String TEXT_25 = NL + "// MESSAGE";
  protected final String TEXT_26 = " IS NOT MAPPED";
  protected final String TEXT_27 = NL + "   DBG002_FUNCTION_EXIT(DBG002_GID_CAN001,CAN001_FUNCTION_EXIT);" + NL + "}" + NL + "  " + NL + "       " + NL + "  " + NL + "/* This function will deinitialize node with the given handle */" + NL + "/*<<<DD_CAN001_API_2>>>*/ " + NL + "void CAN001_NodeDeInit(const CAN001_HandleType* Handle)" + NL + "{" + NL + "  int32_t Count = 0;" + NL + "  uint8_t MsgNo;" + NL + "  uint32_t*\tMsgPndRegOffset = 0;" + NL + "  CAN_MO_TypeDef* CAN_MOxRegs = CAN_MO0;" + NL + "  /* Map to node register offser as per node ID */" + NL + "  CAN_NODE_TypeDef* CAN_NodexRegs = Handle->CanNodeRegs;" + NL + "  DBG002_FUNCTION_ENTRY(DBG002_GID_CAN001,CAN001_FUNCTION_ENTRY);" + NL + "  /* Reset all message object registers and deallocate to free list */" + NL + "  for(Count = (int32_t)(Handle->NodeMONo)-1; Count >= 0; Count--)" + NL + "  {" + NL + "\tMsgNo = (uint8_t)(Handle->FirstMOMapping+(uint32_t)Count);" + NL + "    /* Mapping to message object offset value*/" + NL + "    CAN_MOxRegs = GET_MO_OFFSET(MsgNo);" + NL + "    /* Reset all message objects registers */" + NL + "    CAN_MOxRegs->MOFCR =  (0x00000000U);\t\t\t \t\t" + NL + "    CAN_MOxRegs->MOIPR &= (0x000000FFU);\t\t\t " + NL + "    CAN_MOxRegs->MOAMR = (0x3FFFFFFFU);\t\t\t " + NL + "    CAN_MOxRegs->MODATAL = (0x00000000U);\t" + NL + "    CAN_MOxRegs->MODATAH = (0x00000000U);\t" + NL + "    CAN_MOxRegs->MOAR = (0x00000000U);   " + NL + "    CAN_MOxRegs->MOCTR = (0x00000FFFU);" + NL + "    CAN001_lDeallocateMsgObj(Handle->FirstMOMapping+(uint32_t)Count);" + NL + "  }" + NL + "  /* set CCE and INIT bit NCR for disconnecting the node */" + NL + "  CAN_NodexRegs->NCR = (0x00000041U);" + NL + "  /* reset all node registers */" + NL + "  CAN_NodexRegs->NSR = (0x00000000U);" + NL + "  CAN_NodexRegs->NPCR &= (0x0000000FU);" + NL + "  CAN_NodexRegs->NECNT = (0x00600000U);" + NL + "  CAN_NodexRegs->NFCR = (0x00000000U);" + NL + "  CAN_NodexRegs->NBTR = (0x00000000U);" + NL + "  MsgPndRegOffset = GET_MSGPND_OFFSET(Handle->NodeID);" + NL + "  (*MsgPndRegOffset) = (0x00000000U);" + NL + "  DBG002_FUNCTION_EXIT(DBG002_GID_CAN001,CAN001_FUNCTION_EXIT); " + NL + "}    " + NL + " /* \t\t" + NL + " *  \t\t\t This function is will configure message object as per the message handle" + NL + " *  passed to the function. Function will either Enable or Disable as per" + NL + " *  input parameter" + NL + " */" + NL + "" + NL + "status_t CAN001_ConfigMsgObj" + NL + "(" + NL + "  const CAN001_HandleType* Handle, " + NL + "  const CAN001_MessageHandleType* SwMsgObjptr," + NL + "  uint8_t MsgObjnr" + NL + " )" + NL + "{" + NL + "  uint32_t Error = (uint32_t)CAN001_MO_NOT_FOUND;" + NL + "  uint8_t MsgNo = (uint8_t)(Handle->FirstMOMapping+(MsgObjnr-1U));" + NL + "\t/* Mapping to message object offset value*/" + NL + "  CAN_MO_TypeDef* CAN_MOxRegs = \\" + NL + "                      GET_MO_OFFSET(MsgNo);" + NL + "  /* <<<DD_CAN001_API_3>>> */" + NL + "  DBG002_FUNCTION_ENTRY(DBG002_GID_CAN001,CAN001_FUNCTION_ENTRY);" + NL + "  DBG002_N((MsgObjnr == 0U)||(MsgObjnr > Handle->NodeMONo));" + NL + "    " + NL + "  if (((SwMsgObjptr->IDExten != (uint8_t)STANDARDTYPE) && \\" + NL + "                                        (SwMsgObjptr->IDExten != (uint8_t)EXTENDEDTYPE))" + NL + "    ||((SwMsgObjptr->MsgObjEN != CAN001_ENABLE) && (SwMsgObjptr->MsgObjEN != CAN001_DISABLE))" + NL + "    ||((SwMsgObjptr->MsgObjType != RECMSGOBJ) && (SwMsgObjptr->MsgObjType != TRANSMSGOBJ)))" + NL + "  {" + NL + "    Error =  (uint32_t)CAN001_INVALID_INPUT;" + NL + "    ERROR(DBG002_GID_CAN001,Error, 0, NULL);" + NL + "  }" + NL + "  /* check if message object is to be disabled */" + NL + "  /*<<<DD_CAN001_API_3_1>>>*/" + NL + "  else if (SwMsgObjptr->MsgObjEN == CAN001_DISABLE)" + NL + "  {" + NL + "    /* Reset MSGVAL bit */" + NL + "    CAN_MOxRegs->MOCTR = CAN_MO_MOCTR_RESMSGVAL_Msk;" + NL + "    Error = (uint32_t)DAVEApp_SUCCESS;" + NL + "  } /* if (SwMsgObjptr->MsgObjEN == CAN001_DISABLE) */" + NL + "  else" + NL + "  {" + NL + "    CAN001_lConfigMORegs(SwMsgObjptr, (uint8_t)(Handle->FirstMOMapping+(MsgObjnr-1U)));" + NL + "    Error = (uint32_t)DAVEApp_SUCCESS;" + NL + "  } /*if (SwMsgObjptr->MsgObjEN == CAN001_ENABLE)*/" + NL + "  DBG002_FUNCTION_EXIT(DBG002_GID_CAN001,CAN001_FUNCTION_EXIT);" + NL + "  return Error;" + NL + "}" + NL + "\t" + NL + "" + NL + " /*" + NL + " *\tThis function is will put a transmit request to transmit message object " + NL + " *  for sending data frame" + NL + " */" + NL + "" + NL + " " + NL + "status_t CAN001_SendDataFrame(const CAN001_HandleType* Handle, uint8_t MsgObjnr)" + NL + "{" + NL + "  uint32_t Error = (uint32_t)CAN001_ERROR;" + NL + "  uint8_t MsgNo = (uint8_t)(Handle->FirstMOMapping+(MsgObjnr-1U));" + NL + "  /* Mapping to message object offset value*/" + NL + "  CAN_MO_TypeDef* CAN_MOxRegs = \\" + NL + "                  GET_MO_OFFSET(MsgNo);" + NL + "  /*<<<DD_CAN001_API_4>>>*/" + NL + "  DBG002_FUNCTION_ENTRY(DBG002_GID_CAN001,CAN001_FUNCTION_ENTRY);" + NL + "  DBG002_N((MsgObjnr == 0U)||(MsgObjnr > Handle->NodeMONo));" + NL + "  /* check if message object is not a transmit message object */" + NL + "  /*<<<DD_CAN001_API_4_1>>>*/" + NL + "  if( RD_REG(CAN_MOxRegs->MOSTAT, CAN_MO_MOSTAT_DIR_Msk, \\" + NL + "                                        CAN_MO_MOSTAT_DIR_Pos) != (uint32_t)TRANSMSGOBJ)" + NL + "  {" + NL + "    Error = (uint32_t)CAN001_MO_NOT_ACCEPTABLE;" + NL + "\tDBG002_ERROR(DBG002_GID_CAN001,Error, 0, NULL);" + NL + "  }" + NL + "  /* check if message is disabled */" + NL + "  else if( RD_REG(CAN_MOxRegs->MOSTAT, CAN_MO_MOSTAT_MSGVAL_Msk, \\" + NL + "                                              CAN_MO_MOSTAT_MSGVAL_Pos) == 0U)    " + NL + "  {" + NL + "    Error = (uint32_t)CAN001_MSGOBJ_DISABLED;" + NL + "\tDBG002_INFO(DBG002_GID_CAN001,Error, 0, NULL);" + NL + "  }" + NL + "  /* check if transmission is ongoing on message object */" + NL + "  /*<<<DD_CAN001_API_4_2>>>*/" + NL + "  else if( RD_REG(CAN_MOxRegs->MOSTAT, CAN_MO_MOSTAT_TXRQ_Msk, \\" + NL + "                                                 CAN_MO_MOSTAT_TXRQ_Pos) == 1U)  " + NL + "  {" + NL + "    Error = (uint32_t)CAN001_MO_BUSY;" + NL + "\tDBG002_INFO(DBG002_GID_CAN001,Error, 0, NULL);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    /* set TXRQ bit */" + NL + "    /*<<<DD_CAN001_API_4_3>>>*/" + NL + "    CAN_MOxRegs->MOCTR = CAN_MO_MOCTR_SETTXRQ_Msk;" + NL + "    Error = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  DBG002_FUNCTION_EXIT(DBG002_GID_CAN001,CAN001_FUNCTION_EXIT);" + NL + "  return Error;" + NL + "}" + NL + "\t\t" + NL + "/*" + NL + " *\tThis function is will put a transmit request to receive message object     " + NL + " *  for sending remote frame" + NL + " */" + NL + "" + NL + "status_t CAN001_SendRemoteFrame(const CAN001_HandleType* Handle, uint8_t MsgObjnr)" + NL + "{" + NL + "  uint32_t Error = 0U;" + NL + "  uint8_t MsgNo = (uint8_t)(Handle->FirstMOMapping+(MsgObjnr-1U));" + NL + "  /* Mapping to message object offset value*/" + NL + "  CAN_MO_TypeDef* CAN_MOxRegs = \\" + NL + "                  GET_MO_OFFSET(MsgNo);" + NL + "  /*<<<DD_CAN001_API_5>>>*/" + NL + "  DBG002_FUNCTION_ENTRY(DBG002_GID_CAN001,CAN001_FUNCTION_ENTRY);" + NL + "  DBG002_N ((MsgObjnr == 0U)||(MsgObjnr > Handle->NodeMONo));" + NL + "  /* check if message object is a receive message object */" + NL + "  /*<<<DD_CAN001_API_5_1>>>*/" + NL + "  if( RD_REG(CAN_MOxRegs->MOSTAT, CAN_MO_MOSTAT_DIR_Msk, \\" + NL + "                                        CAN_MO_MOSTAT_DIR_Pos) != (uint32_t)RECMSGOBJ)" + NL + "  {" + NL + "    Error = (uint32_t)CAN001_MO_NOT_ACCEPTABLE;" + NL + "    DBG002_ERROR(DBG002_GID_CAN001,Error, 0, NULL);" + NL + "  }" + NL + "  /* check if message is disabled */" + NL + "  else if( RD_REG(CAN_MOxRegs->MOSTAT, CAN_MO_MOSTAT_MSGVAL_Msk, \\" + NL + "                                              CAN_MO_MOSTAT_MSGVAL_Pos) == 0U)    \t\t" + NL + "  {" + NL + "    Error = (uint32_t)CAN001_MSGOBJ_DISABLED;" + NL + "    DBG002_INFO(DBG002_GID_CAN001,Error, 0, NULL);" + NL + "  }" + NL + "  /* check if transmission is ongoing on message object */" + NL + "  /*<<<DD_CAN001_API_5_2>>>*/" + NL + "  else if( RD_REG(CAN_MOxRegs->MOSTAT, CAN_MO_MOSTAT_TXRQ_Msk, \\" + NL + "                                                CAN_MO_MOSTAT_TXRQ_Pos) == 1U)  " + NL + "  {" + NL + "    Error = (uint32_t)CAN001_MO_BUSY;" + NL + "    DBG002_INFO(DBG002_GID_CAN001,Error, 0, NULL);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    /* Put transmit request to message object */" + NL + "    /*<<<DD_CAN001_API_5_3>>>*/" + NL + "    CAN_MOxRegs->MOCTR = CAN_MO_MOCTR_SETTXRQ_Msk;" + NL + "    Error = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  DBG002_FUNCTION_EXIT(DBG002_GID_CAN001,CAN001_FUNCTION_EXIT);" + NL + "  return Error;" + NL + "}" + NL + "" + NL + "/*" + NL + " *\tThis function is will read the message object data bytes " + NL + " *  into message pointer passed as input parameter" + NL + " */" + NL + "" + NL + "status_t CAN001_ReadMsgObj" + NL + "(" + NL + " const CAN001_HandleType* Handle," + NL + " CAN001_MessageHandleType* SwMsgObjptr," + NL + " uint8_t MsgObjnr" + NL + ")" + NL + "{" + NL + "  uint32_t Error = (uint32_t)CAN001_ERROR;" + NL + "  uint32_t Count = 0U;" + NL + "  bool RxPnd = 0U;" + NL + "  bool NewData = 0U;" + NL + "  uint8_t MsgNo = (uint8_t)(Handle->FirstMOMapping+(MsgObjnr-1U));" + NL + "  /* Mapping to message object offset value*/" + NL + "  CAN_MO_TypeDef* CAN_MOxRegs = \\" + NL + "                 GET_MO_OFFSET(MsgNo);" + NL + "  /*<<<DD_CAN001_API_6>>>*/" + NL + "  DBG002_FUNCTION_ENTRY(DBG002_GID_CAN001,CAN001_FUNCTION_ENTRY);" + NL + "  DBG002_N((MsgObjnr == 0U)||(MsgObjnr > Handle->NodeMONo));" + NL + "  /* check if message object is a receive message object */" + NL + "  /*<<<DD_CAN001_API_6_1>>>*/" + NL + "  if( RD_REG(CAN_MOxRegs->MOSTAT, CAN_MO_MOSTAT_DIR_Msk, \\" + NL + "                                   CAN_MO_MOSTAT_DIR_Pos) != (uint32_t)RECMSGOBJ)" + NL + "  {" + NL + "    Error = (uint32_t)CAN001_MO_NOT_ACCEPTABLE;" + NL + "    DBG002_ERROR(DBG002_GID_CAN001,Error, 0, NULL);" + NL + "  }" + NL + "  /* check if reception is ongoing on message object */" + NL + "  /*<<<DD_CAN001_API_6_2>>>*/" + NL + "  else if( RD_REG(CAN_MOxRegs->MOSTAT, CAN_MO_MOSTAT_RXUPD_Msk, \\" + NL + "                                         CAN_MO_MOSTAT_RXUPD_Pos) == 1U)" + NL + "  {" + NL + "    Error = (uint32_t)CAN001_MO_BUSY;" + NL + "    DBG002_ERROR(DBG002_GID_CAN001,Error, 0, NULL);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    /* read message parameters */" + NL + "    /*<<<DD_CAN001_API_6_3>>>*/" + NL + "    do" + NL + "    {" + NL + "      CAN_MOxRegs->MOCTR = CAN_MO_MOCTR_RESNEWDAT_Msk;" + NL + "      if((RD_REG(CAN_MOxRegs->MOAR, CAN_MO_MOAR_IDE_Msk , \\" + NL + "                         CAN_MO_MOAR_IDE_Pos)) == 0U)" + NL + "      {" + NL + "        SwMsgObjptr->IDExten = (uint8_t)STANDARDTYPE;" + NL + "        SwMsgObjptr->Identifier = (CAN_MOxRegs->MOAR & (uint32_t)CAN_MO_MOAR_STDID_Msk) >> \\" + NL + "                                                    CAN_MO_MOAR_STDID_Pos;" + NL + "        SwMsgObjptr->IDEMask = (uint8_t)((uint32_t)(CAN_MOxRegs->MOAMR & (uint32_t)CAN_MO_MOAMR_MIDE_Msk) >> \\" + NL + "                             CAN_MO_MOAMR_MIDE_Pos);" + NL + "        if(SwMsgObjptr->IDEMask == 1U)" + NL + "        {" + NL + "          SwMsgObjptr->IDMask = (CAN_MOxRegs->MOAMR & (uint32_t)CAN_MO_MOAR_STDID_Msk) >> \\" + NL + "     \t                                             CAN_MO_MOAR_STDID_Pos;" + NL + "        }" + NL + "        else" + NL + "        {" + NL + "     \t   SwMsgObjptr->IDMask = CAN_MOxRegs->MOAMR & (uint32_t)CAN_MO_MOAMR_AM_Msk;" + NL + "        }" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        SwMsgObjptr->IDExten = (uint8_t)EXTENDEDTYPE;" + NL + "        SwMsgObjptr->Identifier = CAN_MOxRegs->MOAR & (uint32_t)CAN_MO_MOAR_ID_Msk;" + NL + "        SwMsgObjptr->IDMask = CAN_MOxRegs->MOAMR & (uint32_t)CAN_MO_MOAMR_AM_Msk;" + NL + "        SwMsgObjptr->IDEMask = (uint8_t)((uint32_t)(CAN_MOxRegs->MOAMR & (uint32_t)CAN_MO_MOAMR_MIDE_Msk) >> \\" + NL + "                                    CAN_MO_MOAMR_MIDE_Pos);" + NL + "      }" + NL + "      SwMsgObjptr->DataLength = (uint8_t)RD_REG(CAN_MOxRegs->MOFCR, \\" + NL + "                             CAN_MO_MOFCR_DLC_Msk, CAN_MO_MOFCR_DLC_Pos);" + NL + "      for(Count = 0U; Count < SwMsgObjptr->DataLength; Count++)" + NL + "      {" + NL + "        if(Count < 4U)" + NL + "        {" + NL + "          SwMsgObjptr->data[Count] = (uint8_t)RD_REG(CAN_MOxRegs->MODATAL, \\" + NL + "                                  (CAN_MO_MODATAL_DB0_Msk << (Count*8U)), \\" + NL + "                                                            (Count*8U));" + NL + "        }" + NL + "        else" + NL + "        {" + NL + "          SwMsgObjptr->data[Count] = (uint8_t)RD_REG(CAN_MOxRegs->MODATAH, \\" + NL + "                                   (CAN_MO_MODATAL_DB0_Msk << ((Count-4U)*8U)) ,\\" + NL + "                                                            ((Count-4U)*8U));" + NL + "        }" + NL + "      }" + NL + "      RxPnd = (bool)CHECK_RXPND_BIT();" + NL + "      NewData = (bool)CHECK_NEWDATA_BIT();" + NL + "    } while((RxPnd != 0U) && (NewData != 0U));" + NL + "     SwMsgObjptr->MsgObjType = RECMSGOBJ;" + NL + "     Error = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  DBG002_FUNCTION_EXIT(DBG002_GID_CAN001,CAN001_FUNCTION_EXIT);" + NL + "  return Error;" + NL + "}" + NL + "" + NL + "" + NL + "/*  This function updates data registers of given message " + NL + " *  object" + NL + " */" + NL + "status_t CAN001_UpdateMODataRegisters" + NL + "(" + NL + "  const CAN001_HandleType* Handle, " + NL + "  uint8_t MsgObjnr," + NL + "  uint8_t DataLength, " + NL + "  const uint8_t* DataPtr" + NL + ")" + NL + "{" + NL + "  uint32_t Error = (uint32_t)CAN001_ERROR;" + NL + "  uint32_t Count = 0U;" + NL + "  uint8_t MsgNo = (uint8_t)(Handle->FirstMOMapping+(MsgObjnr-1U));" + NL + "  /* Mapping to message object offset value*/" + NL + "  CAN_MO_TypeDef* CAN_MOxRegs = \\" + NL + "                  GET_MO_OFFSET(MsgNo);" + NL + "  " + NL + "  /*<<<DD_CAN001_API_7>>>*/" + NL + "  DBG002_FUNCTION_ENTRY(DBG002_GID_CAN001,CAN001_FUNCTION_ENTRY);" + NL + "  DBG002_N((MsgObjnr == 0U)||(MsgObjnr > Handle->NodeMONo));" + NL + "  if (DataLength > 8U)" + NL + "  {" + NL + "    Error = (uint32_t)CAN001_INVALID_INPUT;" + NL + "    DBG002_ERROR(DBG002_GID_CAN001,Error, 0, NULL);" + NL + "  }" + NL + "  /* check if message object is not a transmit message object */" + NL + "  else if( RD_REG(CAN_MOxRegs->MOSTAT, CAN_MO_MOSTAT_DIR_Msk, \\" + NL + "                                        CAN_MO_MOSTAT_DIR_Pos) != (uint32_t)TRANSMSGOBJ)" + NL + "  {" + NL + "    Error = (uint32_t)CAN001_MO_NOT_ACCEPTABLE;" + NL + "\tDBG002_ERROR(DBG002_GID_CAN001,Error, 0, NULL);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    CAN_MOxRegs->MOCTR = CAN_MO_MOCTR_RESMSGVAL_Msk;   " + NL + "    /* Configure data length */" + NL + "    WR_REG(CAN_MOxRegs->MOFCR, (uint32_t)CAN_MO_MOFCR_DLC_Msk, \\" + NL + "                              CAN_MO_MOFCR_DLC_Pos, (uint32_t)DataLength);" + NL + "    for(Count = 0U; Count < DataLength; Count++) " + NL + "    {" + NL + "      if(Count < 4U)" + NL + "      {" + NL + "        WR_REG(CAN_MOxRegs->MODATAL, (uint32_t)(CAN_MO_MODATAL_DB0_Msk << (Count*8U)) , \\" + NL + "                                        (Count*8U), (uint32_t)(*(DataPtr + Count)));" + NL + "      }" + NL + "      else" + NL + "      {" + NL + "        WR_REG(CAN_MOxRegs->MODATAH, (uint32_t)(CAN_MO_MODATAL_DB0_Msk << ((Count-4U)*8U)), \\" + NL + "                                   ((Count-4U)*8U), (uint32_t)(*(DataPtr + Count)));" + NL + "      }" + NL + "    }" + NL + "    /* Reset RTSEL and Set MSGVAL ,TXEN0 and TXEN1, NEWDATA and RXEN */" + NL + "    CAN_MOxRegs->MOCTR = (CAN_MO_MOCTR_SETTXEN0_Msk | \\" + NL + "                        CAN_MO_MOCTR_SETTXEN1_Msk | \\" + NL + "                        CAN_MO_MOCTR_SETRXEN_Msk | \\" + NL + "                        CAN_MO_MOCTR_SETMSGVAL_Msk | \\" + NL + "                        CAN_MO_MOCTR_SETNEWDAT_Msk | \\" + NL + "                        CAN_MO_MOCTR_SETRXEN_Msk | \\" + NL + "                        CAN_MO_MOCTR_RESRTSEL_Msk);" + NL + "    Error = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  DBG002_FUNCTION_EXIT(DBG002_GID_CAN001,CAN001_FUNCTION_EXIT);" + NL + "  return Error;" + NL + "}" + NL + "" + NL + "" + NL + "    " + NL + "/*" + NL + " *  This function is used to return the status of the message object specified. " + NL + " *  The flag value to be returned should be passed as input parameter of " + NL + " *   type MsgStatus " + NL + " */" + NL + "" + NL + "status_t CAN001_GetMOFlagStatus" + NL + "(" + NL + "  const CAN001_HandleType* Handle, " + NL + "  uint8_t MsgObjnr, " + NL + "  CAN_MsgStatusType NewMsgStatus" + NL + " )" + NL + "{" + NL + "  status_t Status = (uint32_t)CAN001_ERROR;" + NL + "  uint8_t MsgNo = (uint8_t)(Handle->FirstMOMapping+(MsgObjnr-1U));" + NL + "\t/* Mapping to message object offset value*/" + NL + "  CAN_MO_TypeDef* CAN_MOxRegs = \\" + NL + "                  GET_MO_OFFSET(MsgNo);" + NL + "   /*<<<DD_CAN001_API_8>>>*/" + NL + "  DBG002_FUNCTION_ENTRY(DBG002_GID_CAN001,CAN001_FUNCTION_ENTRY);" + NL + "  do" + NL + "  {" + NL + "    DBG002_N((MsgObjnr == 0U)||(MsgObjnr > Handle->NodeMONo));" + NL + "    DBG002_N((NewMsgStatus != RECEIVE_PENDING) && (NewMsgStatus != TRANSMIT_PENDING) \\" + NL + "      && (NewMsgStatus != NEW_DATA) && (NewMsgStatus != MESSAGE_LOST));" + NL + "" + NL + "    /* Check message object status */" + NL + "    if((CAN_MOxRegs->MOSTAT & (uint32_t)NewMsgStatus) != 0U)" + NL + "    {" + NL + "      Status = (uint32_t)CAN_SET;" + NL + "    }" + NL + "    else" + NL + "    {" + NL + "      Status = (uint32_t)CAN_RESET;" + NL + "    }" + NL + "  }while(0);" + NL + "  DBG002_FUNCTION_EXIT(DBG002_GID_CAN001,CAN001_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/*  This function is used to return the status of the node specified." + NL;
  protected final String TEXT_28 = " *   The flag value to be returned should be passed as input parameter " + NL + " *   of type MsgStatusType." + NL + " */" + NL + "" + NL + "status_t CAN001_GetNodeFlagStatus" + NL + "(" + NL + "  const CAN001_HandleType* Handle, " + NL + "  CAN001_NodeStatusType NewNodeStatus" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)CAN001_ERROR;" + NL + "  /* Mapping to Node Register offset value*/  " + NL + "  CAN_NODE_TypeDef* CAN_NodexRegs = Handle->CanNodeRegs;" + NL + "  /*<<<DD_CAN001_API_9>>>*/" + NL + "  DBG002_FUNCTION_ENTRY(DBG002_GID_CAN001,CAN001_FUNCTION_ENTRY);" + NL + "  DBG002_N((NewNodeStatus != CAN001_ALERT_STATUS) && (NewNodeStatus != CAN001_ERROR_WARN_STATUS) \\" + NL + "     && (NewNodeStatus != CAN001_BUS_OFF_STATUS) && (NewNodeStatus  != CAN001_LIST_LENGTH_ERROR)\\" + NL + "     && (NewNodeStatus != CAN001_LIST_OBJECT_ERROR));" + NL + "" + NL + "  /* Check Node status */" + NL + "  if ((CAN_NodexRegs->NSR & (uint32_t)NewNodeStatus) != 0U)" + NL + "  {" + NL + "    Status = (uint32_t)CAN_SET;" + NL + "  }" + NL + "  else " + NL + "  {" + NL + "    Status = (uint32_t)CAN_RESET;" + NL + "  }          " + NL + "" + NL + "  DBG002_FUNCTION_EXIT(DBG002_GID_CAN001,CAN001_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "" + NL + "/*  This function will return the message object's message " + NL + " *  pending register bit value" + NL + " */" + NL + "" + NL + "status_t CAN001_GetMOPndRegisterBitStatus" + NL + "(" + NL + "  const CAN001_HandleType* Handle, " + NL + "  uint8_t MsgObjnr" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)CAN001_ERROR;" + NL + "  uint32_t* MsgPndRegOffset;" + NL + "  /*<<<DD_CAN001_API_11>>>*/" + NL + "  DBG002_FUNCTION_ENTRY(DBG002_GID_CAN001,CAN001_FUNCTION_ENTRY);" + NL + "  DBG002_N((MsgObjnr == 0U)||(MsgObjnr > Handle->NodeMONo));" + NL + "  MsgPndRegOffset = GET_MSGPND_OFFSET(Handle->NodeID);" + NL + "  Status = RD_REG((*MsgPndRegOffset), (CAN_MSPND_PND_Msk << (MsgObjnr-1U)), \\" + NL + "                                                                  (MsgObjnr-1U));" + NL + "  DBG002_FUNCTION_EXIT(DBG002_GID_CAN001,CAN001_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "" + NL + "/*  This function is used to clear the status bits of message object" + NL + " *  register MOSTATx. The input parameter can be a combination of " + NL + " *  enum type MsgStatus" + NL + " */" + NL + "" + NL + "status_t CAN001_ClearMOFlagStatus" + NL + "(" + NL + "  const CAN001_HandleType* Handle, " + NL + "  uint8_t MsgObjnr, " + NL + "  CAN_MsgStatusType NewMsgStatus" + NL + ")" + NL + "{" + NL + "  status_t Status = (uint32_t)CAN001_ERROR;" + NL + "  uint8_t MsgNo = (uint8_t)(Handle->FirstMOMapping+(MsgObjnr-1U));" + NL + "  /* Mapping to message object offset value*/" + NL + "  CAN_MO_TypeDef* CAN_MOxRegs = \\" + NL + "                  GET_MO_OFFSET(MsgNo);" + NL + "  /*<<<DD_CAN001_API_12>>>*/" + NL + "  DBG002_FUNCTION_ENTRY(DBG002_GID_CAN001,CAN001_FUNCTION_ENTRY);" + NL + "  if ((MsgObjnr == 0U)||(MsgObjnr > Handle->NodeMONo))" + NL + "  {" + NL + "    Status = (uint32_t)CAN001_MO_NOT_FOUND;" + NL + "    ERROR(DBG002_GID_CAN001,Status, 0, NULL);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    CAN_MOxRegs->MOCTR = CAN001_CLEAR_MO_STATUS_MASK & (uint32_t)NewMsgStatus;" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  DBG002_FUNCTION_EXIT(DBG002_GID_CAN001,CAN001_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}\t" + NL + "" + NL + "/*  This function is used to clear the status bits of Node " + NL + " *   register NSRx. The input parameter can be a combination" + NL + " *   of enum type NodeStatus  " + NL + " */" + NL + "" + NL + "void CAN001_ClearNodeFlagStatus" + NL + "(" + NL + "  const CAN001_HandleType* Handle, " + NL + "  CAN001_NodeStatusType NewNodeStatus" + NL + ")" + NL + "{" + NL + "  /* Mapping to Node Register offset value*/  " + NL + "  CAN_NODE_TypeDef* CAN_NodexRegs = Handle->CanNodeRegs;" + NL + "  /*<<<DD_CAN001_API_13>>>*/" + NL + "  DBG002_FUNCTION_ENTRY(DBG002_GID_CAN001,CAN001_FUNCTION_ENTRY);" + NL + "  CAN_NodexRegs->NSR &= ~((uint32_t)NewNodeStatus & \\" + NL + "                                              CAN001_CLEAR_NODE_STATUS_MASK); \t" + NL + "  DBG002_FUNCTION_EXIT(DBG002_GID_CAN001,CAN001_FUNCTION_EXIT);" + NL + "}" + NL + "" + NL + "" + NL + "" + NL + "" + NL + "/*  These function is used to clear message pending register bit" + NL + " *  of specific message object." + NL + " */" + NL + "" + NL + "status_t CAN001_ClearMOPndRegisterBit(const CAN001_HandleType* Handle, uint8_t MsgObjnr)" + NL + "{" + NL + "  status_t Status = (uint32_t)CAN001_ERROR;" + NL + "  uint32_t* MsgPndRegOffset = 0;" + NL + "  /*<<<DD_CAN001_API_14>>>*/" + NL + "  DBG002_FUNCTION_ENTRY(DBG002_GID_CAN001,CAN001_FUNCTION_ENTRY);" + NL + "  if ((MsgObjnr == 0U)||(MsgObjnr > Handle->NodeMONo))" + NL + "  {" + NL + "    Status = (uint32_t)CAN001_MO_NOT_FOUND;" + NL + "    ERROR(DBG002_GID_CAN001,Status, 0, NULL);" + NL + "  }" + NL + "  else" + NL + "  {" + NL + "    MsgPndRegOffset = GET_MSGPND_OFFSET(Handle->NodeID);" + NL + "    CLR_BIT((*MsgPndRegOffset), (MsgObjnr-1U));" + NL + "    Status = (uint32_t)DAVEApp_SUCCESS;" + NL + "  }" + NL + "  DBG002_FUNCTION_EXIT(DBG002_GID_CAN001,CAN001_FUNCTION_EXIT);" + NL + "  return Status;" + NL + "}" + NL + "" + NL + "/**" + NL + " *@}" + NL + " */" + NL + "" + NL + "/*CODE_BLOCK_END*/ " + NL;
  protected final String TEXT_29 = NL;

  public String generate(Object argument)
  {
    final StringBuffer stringBuffer = new StringBuffer();
     App2JetInterface app = (App2JetInterface) argument; 
     String AppBaseuri = "app/can001/";
    stringBuffer.append(TEXT_1);
    stringBuffer.append( app.getAppVersion(AppBaseuri));
    stringBuffer.append(TEXT_2);
     String TempApps = null;
   String MyAppName = null;
   ArrayList<String> apps;
   String TempLowerApps = null; 
   boolean DBGApp = false;   
   apps=(ArrayList<String>)(app.getApps());
        for (int k = 0; k < apps.size(); k++) {
              TempApps = apps.get(k);
//            if(app.isAppInitProvider(apps.get(k)) == true) {
              MyAppName = TempApps.substring(TempApps.indexOf("/app/") + 5, TempApps.lastIndexOf("/"));
              TempLowerApps = MyAppName.toLowerCase();
              if (TempLowerApps.equalsIgnoreCase("dbg002")) {DBGApp = true;}   
//   }  
  } 
    stringBuffer.append(TEXT_3);
     if (!DBGApp) { 
    stringBuffer.append(TEXT_4);
     } 
    stringBuffer.append(TEXT_5);
     String P = "http://www.infineon.com/0.1.28/port/p/"; 
     String MappedUri = null; 
     String nodeInst = null; 
     String appInst  = null; 
    stringBuffer.append(TEXT_6);
     ArrayList<String> appsList = (ArrayList<String>)(app.getApps("app/can001/"));
 for (String appIns : appsList ) {
 appInst = appIns.substring(appIns.lastIndexOf("/")+1);
     MappedUri = app.getMappedUri(AppBaseuri + appInst + "/node"); 
     if((MappedUri != null) && (MappedUri != "")) { 
     nodeInst = MappedUri.substring(MappedUri.lastIndexOf("/")+1).trim(); 
    stringBuffer.append(TEXT_7);
    stringBuffer.append( nodeInst);
    stringBuffer.append(TEXT_8);
    stringBuffer.append( appInst);
    stringBuffer.append(TEXT_9);
     int AlertIntr = app.getIntegerValue(AppBaseuri + appInst +"/node/ncr/alie"); 
     if (AlertIntr == 1) {
    stringBuffer.append(TEXT_10);
    stringBuffer.append( appInst);
    stringBuffer.append(TEXT_11);
     } 
     } 
     else { 
    stringBuffer.append(TEXT_12);
     } 
     int mono = app.getIntegerValue(AppBaseuri + appInst + "/can001_irwnodenomsgobjs"); 
     for (int Msg=1; Msg<=mono; Msg++) { 
     MappedUri = app.getMappedUri(AppBaseuri + appInst +"/message" + Msg + "/mofcr"); 
     if((MappedUri != null) && (MappedUri != "")) { 
    stringBuffer.append(TEXT_13);
    stringBuffer.append(Msg );
    stringBuffer.append(TEXT_14);
    stringBuffer.append( appInst);
    stringBuffer.append(TEXT_15);
    stringBuffer.append( appInst);
    stringBuffer.append(TEXT_16);
    stringBuffer.append(Msg );
    stringBuffer.append(TEXT_17);
    stringBuffer.append(Msg );
    stringBuffer.append(TEXT_18);
     int TxIntr = app.getIntegerValue(AppBaseuri + appInst +"/message" + Msg + "/mofcr/txie"); 
     if (TxIntr == 1) {
    stringBuffer.append(TEXT_19);
    stringBuffer.append( appInst);
    stringBuffer.append(TEXT_20);
    stringBuffer.append(Msg );
    stringBuffer.append(TEXT_21);
     } 
     int RxIntr = app.getIntegerValue(AppBaseuri + appInst +"/message" + Msg + "/mofcr/rxie"); 
     if (RxIntr == 1) {
    stringBuffer.append(TEXT_22);
    stringBuffer.append( appInst);
    stringBuffer.append(TEXT_23);
    stringBuffer.append(Msg );
    stringBuffer.append(TEXT_24);
     } 
     } 
     else { 
    stringBuffer.append(TEXT_25);
    stringBuffer.append(Msg);
    stringBuffer.append(TEXT_26);
     } 
    } 
    } 
    stringBuffer.append(TEXT_27);
    stringBuffer.append(TEXT_28);
    stringBuffer.append(TEXT_29);
    return stringBuffer.toString();
  }
}
